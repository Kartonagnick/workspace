
[Оригинал](https://github.com/semver/semver)

Семантическое Версионирование v2.0.0
====================================

Кратко
------
Версия задаётся в формате: `major.minor.patch.build.extra`  

- МАЖОР увеличиваем, когда сделаны обратно несовместимые изменения API.  
- МИНОРНУЮ увеличиваем, когда добалвяется обратно совместимая функциональность.  
- ПАТЧ-версия увеличивается, когда вносятся обратно совместимые исправления.  
Остальные тэги на усмотрение конкретного разработчика.  

Вступление
----------
В мире управления процессом разработки есть понятие «ад зависимостей» (dependency hell).  
Чем больше растёт система, тем больше библиотек в неё интегрируется.  
И тем больше вероятность оказаться в этой ситуации.  
Выпуск новой версии системы, у которой есть множество зависимостей,  
может быстро превраться в кошмар.  
Выпуск новой версии может быть блокирован 
необходимостью обновления всех зависимыых библиотек.  

Если спецификация зависимостей слишком свободна,  
вас неизбежно настигнет версионное несоответствие  
(необоснованное предположение совместимости с будущими версиями).  
В качестве решения данной проблемы я предлагаю простой набор правил и требований,  
которые определяют, как назначаются и увеличиваются номера версий.  
Для того чтобы эта система работала, вам необходимо определить публичный API.  
Он может быть описан в документации, или определяться самим кодом.  
Главное, чтобы этот API был ясным и точным.  
Однажды определив публичный API,  
вы сообщаете об изменениях в нём особым увеличением номера версий.  
Рассмотрим формат версий X.Y.Z (мажорная, минорная, патч).  
Баг-фиксы, не влияющие на API, увеличивают патч-версию,  
Обратно совместимые добавления/изменения API увеличивают минорную версию.  
И обратно несовместимые изменения API увеличивают мажорную версию.  
Я называю эту систему «Семантическое Версионирование» (Semantic Versioning).  

По этой схеме номера версий и то, как они изменяются,  
передают смысл содержания исходного кода,  
и что было модифицировано от одной версии к другой.  

Спецификация Семантического Версионирования (SemVer)
----------------------------------------------------
Слова:  
- «ДОЛЖЕН» (MUST),  
- «НЕ ДОЛЖЕН» (MUST NOT),  
- «ОБЯЗАТЕЛЬНО» (REQUIRED),  
- «СЛЕДУЕТ» (SHOULD),  
- «НЕ СЛЕДУЕТ» (SHOULD NOT),  
- «РЕКОМЕНДОВАННЫЙ» (RECOMMENDED),  
- «МОЖЕТ» (MAY),  
- «НЕОБЯЗАТЕЛЬНЫЙ» (OPTIONAL)  
В этом документе должны быть интерпретированы в соответствии с [RFC 2119][RFC]  


1. ПО, использующее Семантическое Версионирование, должно объявить публичный API.  
   Этот API может быть объявлен самим кодом или существовать только в документации.  
   Как бы ни было это сделано, оно должен быть точным и исчерпывающим.  

2. Номер версии ДОЛЖЕН иметь формат X.Y.Z,  
   где X, Y и Z — неотрицательные целые числа,  
   и НЕ ДОЛЖНЫ начинаться с нуля.  
   - X — мажорная версия,  
   - Y — минорная версия,  
   - Z — патч-версия.  
   Каждый элемент ДОЛЖЕН увеличиваться численно.  
   Например: `1.9.0` -> `1.10.0` -> `1.11.0`.  

3. После релиза новой версии,  
   содержимое предыдущей версии НЕ ДОЛЖНО больше модифицироваться.  
   Любые изменения ДОЛЖНЫ быть выпущены в контексте новой версии.  

4. Мажорная версия ноль (0.y.z) предназначена для начальной разработки.  
   Всё может измениться в любой момент.  
   Публичный API не должен рассматриваться как стабильный.  

5. Версия 1.0.0 определяет стабильный публичный API.  
   После этого релиза номера версий увеличиваются в зависимости от того,  
   как изменяется публичный API.  

6. Патч-версия Z (x.y.Z | x > 0) ДОЛЖНА быть увеличена,  
   только если содержит обратно совместимые баг-фиксы.  
   Баг-фикс - это внутренние изменения,  
   которые исправляют некорректное поведение.  

7. Минорная версия (x.Y.z | x > 0) ДОЛЖНА быть увеличена,  
   если в публичном API представлена новая обратно совместимая функциональность.  
   Так же, минорная версия ДОЛЖНА быть увеличина,  
   если в публичном API объявляется устаревший (deprecated) функционал.  
   Так же, минорная версия МОЖЕТ быть увеличина,  
   если в приватном коде появилась новая функциональность,  
   или были существенные усовершенствования.  
   При инкрменте минорной версии, Патч-версия ДОЛЖНА быть обнулена.  

8. Мажорная версия X (X.y.z | X > 0) ДОЛЖНА быть увеличена,  
   если в публичном API ппоявились изменения,  
   нарушающие обратную совместимость.  
   Мажорная версия МОЖЕТ включать в себя изменения,  
   характерные для минорных версий или патчей.  
   Когда увеличивается мажорная версия,  
   минорная и патч-версия ДОЛЖНЫ быть обнулены.  

9. Предрелизная версия МОЖЕТ быть обозначена добавлением дефиса,  
   и серией разделённых точкой идентификаторов,  
   следующих сразу за патч-версией.  
   Идентификаторы ДОЛЖНЫ содержать только ASCII буквенно-цифровые символы и дефис [0-9A-Za-z-].  
   Идентификаторы НЕ ДОЛЖНЫ быть пустыми.  
   Числовые идентификаторы НЕ ДОЛЖНЫ начинаться с нуля.  
   Предрелизные версии имеют более низкий приоритет,  
   чем соответствующая релизная версия.  
   Предрелизная версия указывает на то,  
   что эта версия не стабильна,  
   и может не удовлетворять требованиям совместимости,  
   обозначенными соответствующей нормальной версией.  
   Например: `1.0.0-alpha`, `1.0.0-alpha.1`, `1.0.0-0.3.7`, `1.0.0-x.7.z.92`.  

10. Сборочные метаданные МОГУТ быть обозначены добавлением знака плюс,  
    и ряда разделённых точкой идентификаторов,  
    следующих сразу за патчем или предрелизной версией.  
    Идентификаторы ДОЛЖНЫ содержать только ASCII буквенно-цифровые символы или дефис [0-9A-Za-z-].  
    Идентификаторы НЕ ДОЛЖНЫ быть пустыми.  
    Сборочные метаданные СЛЕДУЕТ игнорировать, когда определяется старшинство версий.  
    Поэтому два пакета с одинаковой версией, но разными сборочными метаданными,  
    рассматриваются как одна и та же версия.  
    Примеры: `1.0.0-alpha+001`, `1.0.0+20130313144700`, `1.0.0-beta+exp.sha.5114f85`.  

11. Приоритет определяет,  
    как версии соотносятся друг с другом, когда упорядочиваются.  
    Приоритет версий ДОЛЖЕН рассчитываться путём разделения номеров версий на мажорную,  
    минорную, патч и предрелизные идентификаторы.  
    Именно в такой последовательности (сборочные метаданные не фигурируют в расчёте).  
    Приоритет определяется по первому отличию  
    при сравнении каждого из этих идентификаторов слева направо:  
    Мажорная, минорная и патч-версия всегда сравниваются численно.  
    Например: `1.0.0` < `2.0.0` < `2.1.0` < `2.1.1.`  
    Когда мажорная, минорная и патч-версия равны,  
    предрелизная версия имеет более низкий приоритет,  
    чем нормальная версия.  
    Наппимер: `1.0.0-alpha` < `1.0.0.`  
    Приоритет двух предрелизных версий с одинаковыми мажорной, минорной и патч-версией,  
    ДОЛЖНЫ быть определены сравнением каждого разделённого точкой идентификатора  
    слева направо до тех пор,  
    пока различие не будет найдено следующим образом:  
    идентификаторы, состоящие только из цифр, сравниваются численно;  
    буквенные идентификаторы или дефисы сравниваются лексически в ASCII-порядке.  
    Численные идентификаторы всегда имеют низший приоритет, чем символьные.  
    Больший набор предрелизных символов +имеет больший приоритет,  
    чем меньший набор, если сравниваемые идентификаторы равны.  
    Пример: `1.0.0-alpha` < `1.0.0-alpha.1` < `1.0.0-alpha.beta` < `1.0.0-beta` < `1.0.0-beta.2` < `1.0.0-beta.11` < `1.0.0-rc.1` < `1.0.0.`  

Зачем использовать семантическое версионирование?
-------------------------------------------------
Это не новая или революционная идея.  
Вероятно, вы уже используете что-то подобное.  
Проблема в том, что «подобное» — не достаточно хорошо.  
Без соответствия формальной спецификации,  
номера версий практически бесполезны для управления зависимостями.  
Ясно определив и сформулировав идею версионирования,  
становится легче сообщать о намерениях пользователям вашего ПО.  
Когда эти намерения ясны, гибки (но не слишком),  
спецификации зависимостей наконец могут быть созданы.  


Пример
------

На практике номер версии программного решения,  
который вы разрабатываете,  
может являться неким маркетинговым инструментом,  
и может изменяться по своим уже устоявшимся правилам,  
и даже может вам, как разработчику, не принадлежать.  
Важно понимать, что номер версии программного решения  
может не совпадать с номером версии публичного API данного приложения.  
Увеличение номера версии приложения может не увеличивать номер версии публичного API.  
И вы, как разработчик, можете ввести версионирование вашего публичного API.  

Например, внутри вашего решения есть REST API.  
Вы можете использовать semver для его версионирования.  
Сообщать версии API можно через http заголовок accept в каждом ответе вашего API:  
```
{
  "accept": "application/myservice_api-0.5.1+json",
  "date": "Mon, 05 Feb 2018 02:12:05 GMT",
  "transfer-encoding": "chunked",
  "content-type": "application/json;charset=UTF-8"
}     
```
Все клиенты могут проверять accept заголовок ответов вашего API,  
и "понимать" могут ли они работать с API данной версии или нет.  


FAQ
---
### Что я должен делать с ревизиями в 0.y.z на начальной стадии разработки?
Самое простое — начать разработку с 0.1.0,  
и затем увеличивать минорную версию для каждого последующего релиза.  

### Как я узнаю, когда пора делать релиз 1.0.0?
- Если ваше ПО используется на продакшене,  
  оно, вероятно, уже должно быть версии 1.0.0.  

- Если у вас стабильный API,  
  от которого зависят пользователи,  
  версия должна быть 1.0.0.  

- Если вы беспокоитесь за обратную совместимость,  
  вероятно, версия вашего ПО уже 1.0.0.  


### Не препятствует ли это быстрой разработке и коротким итерациям?
Мажорная версия 0 как раз и означает быструю разработку.  
Если вы изменяете API каждый день,  
вы должны быть на версии 0.y.z,  
или на отдельной ветке разработки работать над следующей главной версией.  


### Даже если малейшие обратно несовместимые изменения в публичном API требуют выпуска новой главной версии, не закончится ли это тем, что очень скоро версия станет 42.0.0?
Это вопрос ответственной разработки и предвидения.  
Несовместимые изменения не должны быть представлены как незначительные в ПО,  
имеющем много зависимого кода.  
Стоимость обновления может быть велика.  
Практика увеличения главных версий релизов с обратно несовместимыми изменениями означает,  
что вам придётся думать о последствиях ваших изменений,  
и учитывать соотношение цена/качество.  


### Документирование всего API — слишком много работы!

ПО для широкого круга использования нуждается в правильной документации.  
Создание такой документации - это ваша ответственность,  
как профессионального разработчика.  

Управление сложностью ПО - важная часть поддержки проекта.  
Управлять сложностью ПО - проблематично, если никто не знает,  
какой метод можно вызывать безопасно.  

В долгосрочной перспективе "Семантическое Версионирование",  
и качественная документация поможет сохранить эффективность разработки.  


### Что мне делать, если я случайно зарелизил обратно несовместимые изменения как минорную версию?

- Ввыпустите новую минорную версию,  
  которая исправляет проблему,  
  и восстанавливает обратную совместимость.  

- Даже в таких обстоятельствах неприемлемо модифицировать  
  уже выпущенные релизы.  

- Если это необходимо,  
  укажите в документации о нарушении обратной совместимости,  
  и проинформируйте ваших пользователей,  

### Что я должен делать, если я обновляю свои собственные зависимости без изменения публичного API?
- Так как такие изменения не влияют на публичный API,  
  то такие изменения - совместимые.  

- ПО, которое явно зависит от тех же зависимостей что и ваш пакет,  
  должно иметь собственные спецификации зависимостей,  
  и автор будет уведомлен о возможных конфликтах.  

- Являются ли данные изменения уровня патча или минорного уровня,  
  зависит от того, обновили ли вы свои зависимости чтобы исправить баг,  
  или реализовать новую функциональность.  
  В последнем случае, как правило,  
  добавляется некоторое количество дополнительного кода и как следствие,  
  увеличивается минорная версия.  

### Что если я нечаянно изменил публичный API в несоответствии с изменением номера версии (т.е. код содержит обратно несовместимые изменения в патч-релизе)?
На ваше усмотрение.  
Если у вас огромная аудитория,  
которая будет поставлена перед фактом возвращения прежнего поведения API,  
то лучше выпустить новый релиз с увеличением главной версии, даже несмотря на то,  
что фикс содержит исправления уровня патча.  
Запомните, в Семантическом Версионировании номера версий изменяются строго следуя спецификации.  
Если эти изменения важны для ваших пользователей,  
используйте номер версии, чтобы информировать их.  

### Что делать с устаревшей функциональностью?
Когда вы объявляете устаревшим часть публичного API, вы должны сделать две вещи:  
  - Обновить вашу документацию, 
     чтобы дать пользователям узнать об этом изменении.  
  - Выпустить новый релиз с увеличением минорной версии.  

Как минимум должен быть хотя бы один минорный релиз.  
После чего устаревшую функциональность уже можно удалить,  
и выпустить мажорный релиз.  

Такая мера нужна,  
чтобы пользователи могли плавно перейти на новый API.  

### Есть ли в SemVer лимиты на длину строки версии?
Нет.  
Но руководствуйтесь здравым смыслом.  
255 символов в строке версии, пожалуй, перебор.  
Кроме того, определенные системы могут предъявлять  
свои собственные ограничения на размер строки.  

Об авторе
---------
Авторство спецификаций Семантического Версионирования принадлежит [Тому Престон-Вернеру][TW].  
Он является основателем Gravatars, и соучредителю GitHub.  

Если вы хотите оставить отзыв, пожалуйста, создайте запрос на [GitHub][GH].  

[RFC]: https://datatracker.ietf.org/doc/html/rfc2119 "RFC 2119"
[TW]:  https://tom.preston-werner.com "Том Престон-Вернер - автор спецификации Семантического Версионирования"  
[GH]:  https://github.com/semver/semver/issues "задать вопрос на github"


