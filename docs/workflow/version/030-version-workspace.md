
Пререквизиты  
------------  
Прежде чем читать данный документ,  
ознакомьтесь с вводным материалом:  

1) Что такое "[версия][VER]" ?  
2) Концепция "[Семантического Версионирования][SV]"  

<details>
<summary>Принятые в данном файле понятия</summary>

1) Деталь - небольшой, функционально законченный фрагмент программы.  
   Предназначен для многоразового использования в различных программах.  
   В одном файле может быть множество различных деталей.  

2) Субмодуль - крупный, функционально законченный фрагмент программы,  
   оформленный в виде одного или нескольких файлов.  
   Предназначен для мноразового переиспользования  
   в различных программах.  

3) Проект - исходный код разрабатываемой библиотеки, или приложения.  
   Проекты состоят из отдельных деталей, и субмодулей.  

</details>

[VER]: 010-version-format.md     "общие сведения"  
[SV]:  020-version-semantic.md   "семантическое версионирование"  

Правила версионирования 0.0.1  
=============================
1. Все функционально законченные элементы проекта,  
    у которых есть публичное API,  
   обязательно должны быть версионированны.  

2. Версия задаётся:  
   - на уровне [файла][VF] (контейнер для деталей)  
   - на уровне [деталей][VD] (которых может быть несколько в одном файле)  
   - на уровне [субмодуля][VS] (может охватывать несколько файлов)  
   - на уровне [проекта][VP] (может охватывать несколько субмодулей)  
   
[VF]: #Версия-на-уровне-файла       "правила версионирования файлов"     
[VD]: #Версия-на-уровне-деталей     "правила версионирования деталей"     
[VS]: #Версия-на-уровне-субмодулей  "правила версионирования субмодулей"     
[VP]: #Версия-на-уровне-проекта     "правила версионирования проекта"     

Версия на уровне файла  
---
Пример 1:  
   
```
// [2021y-03m-31d][22:57:11] Idrisov Denis R. 101 PRE   
// [2021y-02m-07d][18:40:18] Idrisov Denis R. 100
// [2021y-02m-06d][13:42:45] Idrisov Denis R. 100 PRE
#pragma once
#ifndef dTOOLS_ASSERT_USED_
#define dTOOLS_ASSERT_USED_ 101 PRE
    ... код файла
#endif // dTOOLS_ASSERT_USED_
```

Пример 2:  

```
//  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  + changed: 2021y-05m-08d 23:51:15 May          101       Idrisov D. R +
//  + created: 2021y-04m-20d 16:12:59 April        100       Idrisov D. R +
//  + macro.hpp                                                           +
//  +                                                     Tools's library +
//  +                                  Copyright @ 2021, Castle Of Dreams +
//  +                                              [author: Idrisov D. R] +
//  +                                            CastleOfDreams@yandex.ru +
//  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#pragma once
#ifndef dTOOLS_MACRO_USED_
#define dTOOLS_MACRO_USED_ 101

#define dMACRO_MAJOR 1
#define dMACRO_MINOR 0
#define dMACRO_PATCH 1

#endif // dTOOLS_MACRO_USED_
```

1. В самом верху файла вписывается запись об очередном изменении файла.  
   При этом старые записи оказываются ниже.  

   <details>
   <summary>Формат записи</summary>

   Полная запись изменений включает в себя:  
   - дату изменения.  
   - время изменения.  
   - автора изменения.  
   - версию изменения.  

   <br/>
   
   Постфикс `PRE` означает,  
   что на тот момент версия файла была предварительной.  
   Предварительные версии задаются на этапе разработки.  

   Если постфикс `PRE` отсутствует, значит версия - релизная.  
   То есть, версия была выпущена в очередном релизе проекта.  

   Записи об изменениях предназначены для истории,  
   и оценки динамики изменений.  

   </details>

2. Чуть ниже опционально вписывается `#pragma once`

3. Ещё ниже указывается header-guard  
   Именно хэдер-гвард и содержит формальную версию файла.  

   <details>
   <summary>Подробности</summary>

   - Версия задается в виде макроса препроцессора  
     Что бы можно было проверять её на этапе препроцессирования.  

   <br/>

   Типичный формат версии: `major.minor.patch`,  
   только без точек, и каждый тэг состоит всего из одной цифры.  
   Если этого не достаточно, то можно использовать [альтернативные форматы][MV],  
   которые можно сравнивать времени препроцессирования.  

   </details>
   
   [MV]: https://github.com/Kartonagnick/tools-macro/blob/master/docs/code/macro/make_version.md     
         "субмодуль для работы с различными форматами версий"     


Версия на уровне деталей  
---
Детали - небольшие, логически завершенные блоки программы.  
Их может быть несколько в одном файле.  

Пример:  

```
// [2021y-04m-30d][01:24:10] Idrisov Denis R. 14 PRE
// [2021y-04m-21d][00:41:22] Idrisov Denis R. 13
#ifndef dTOOLS_TRAITS_USED_ 
#define dTOOLS_TRAITS_USED_ 14 PRE

    #ifndef dTOOLS_INTEGRAL_CONSTANT_USED_ 
    #define dTOOLS_INTEGRAL_CONSTANT_USED_ 1
        ...код первого элемента
    #endif // !dTOOLS_INTEGRAL_CONSTANT_USED_
    
    #ifndef dTOOLS_REMOVE_EXTENT_USED_ 
    #define dTOOLS_REMOVE_EXTENT_USED_ 1
        ...код второго элемента
    #endif // !dTOOLS_REMOVE_EXTENT_USED_
    
#endif // dTOOLS_TRAITS_USED_
```

1. Обязательно должна быть указанна [версия файла][VF]  
2. Каждая деталь имеет свой собственный header-guard  
   который и содержит формальную версию детали.  
3. Согласно [Семантическому Версионированию][SV]  
   изменение версии любой детали приводит к изменению [версии файла][VF]  

Версия на уровне субмодулей  
---

Пример:  

```
#pragma once
#ifndef dTOOLS_MACRO_USED_
#define dTOOLS_MACRO_USED_ 102

#define dMACRO_MAJOR 1
#define dMACRO_MINOR 0
#define dMACRO_PATCH 2

#endif // dTOOLS_MACRO_USED_
```

<details>
<summary>Терминология</summary>

Субмодуль - крупный, функционально законченный фрагмент программы.  
Как правило, располагается в своём отдельном каталоге.  
Может иметь подкаталоги, и состоять из множества файлов,  
которые в свою очередь могут содержать множество деталей.  

`WorkSpace настоятельно не рекомендует`  
Разрабатывать несколько субмодулей в рамках одного проекта.  

Субмодули лучше подключать к проекту уже в готовом виде.  
Путем копирования исходников, или подключая при помощи git.  
А вот разработку субмодулей лучше вести в своих отдельных репозиториях.  
Такая мера с одной стороны упрощает ведение истории главного проекта,  
а с другой - позволяет сохранить детализацию изменений в субмодуле.  

</details>

1. Версия субмодуля указывается одним из следующих способов:  
   - `ИмяСубмодуля_version.hpp`  
   - `version_ИмяСубмодуля.hpp`  
   - `ИмяСубмодуля.hpp`  
   - `ИмяСубмодуля.ver`  
  
2. Cогласно [Семантическому Версионированию][SV]  
   изменение версии любой детали приводит к изменению [версии субмодуля][VS]  
   А изменение версии субмодуля приводит к изменению [версии проекта][VP]  

<details>
<summary>Рекомендация</summary>

WorkSpace рекомендует указывать версию в отдельном файле: `ИмяСубмодуля.ver`  
При таком варианте сразу видно название субмодуля,   
и сразу понятно где можно подсмотреть номер версии.    

WorkSpace не рекомендует указывать версию в файле: `ИмяСубмодуля.hpp`  
Этот файл, как правило, содержит много различного кода.
Подключать весь этот код только ради трех макросов,
это не всегда бывает целесообразно.  
</details>


<details>
<summary>Подробности</summary>

Обратите внимание:  
Здесь так же, действуют правила версионнирования [файла][VF]  
То есть, версия указывается в header-guard.  
Но помимо этого, версия так же указывается в виде 3х отдельных элементов:  
  - `ИмяСубмодуля_MAJOR`, `ИмяСубмодуля_MINOR`, `ИмяСубмодуля_PATCH`  

Три отдельных элемента нужны,  
что бы различные инструменты смогли извлекать информацию  
в автоматическом режиме.  

Например, bat_engine определяет версию проекта,  
выполняя поиск по маскам:  
 - `*_MAJOR`, `*_MINOR`, `*_PATCH`  

Примерно аналогичным образом,  
build_info определяет версию субмодуля,  
и печатает её в лог компиляции.  

</details>


Версия на уровне проекта  
---
Пример:  

```
#pragma once
#ifndef dTOOLS_USED_
#define dTOOLS_USED_ 102

#define dTOOLS_MAJOR 1
#define dTOOLS_MINOR 0
#define dTOOLS_PATCH 2
```

Проект - исходный код разрабатываемой библиотеки, или приложения.  
Проекты состоят из отдельных деталей, и субмодулей.  

По аналогии с [субмодулями][VS], проекты имеют файл,  
где аналогичным образом указывается версия.  

Как правило, вместе с проектом поставляется файл `project.root`,  
который находится в корне каталога проекта.  
В этом файле указывается путь к файлу,  
который содержит версию проекта.  

Например:  
```
INCLUDE_CONFIGURATIONS =
EXCLUDE_CONFIGURATIONS = 
VERSION = include/tools/tools.ver
```

Здесь: `VERSION` задает путь относительно корня проекта к файлу,  
который содержит версию проекта.  

[Подробности][PR] о файле `project.root`

[PR]:  https://github.com/Kartonagnick/bat_engine-windows/blob/master/docs/public/005-project_root.md 
       "семантическое версионирование"  
